<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Análisis de datos estadísticos en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Valentina Andrade y Nicolás Godoy" />
    <meta name="date" content="2021-10-02" />
    <script src="libs/header-attrs-2.10/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <script type="application/json" id="xaringanExtra-editable-docid">{"id":"xef64425a036415da3529d302d6a1a6e","expires":14}</script>
    <script src="libs/himalaya-1.1.0/himalaya.js"></script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <link href="libs/editable-0.2.6/editable.css" rel="stylesheet" />
    <script src="libs/editable-0.2.6/editable.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <script src="libs/fabric-4.3.1/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble-0.0.1/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble-0.0.1/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\">Copiar código<\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\">¡Listo!<\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/ath-slides.css" type="text/css" />
    <link rel="stylesheet" href="css/ath-inferno-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/animate.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">











class: center middle main-title section-title-1 top-logo

.small[
# Muestras complejas y precisión de inferencia estadística
]

.class-info[
&lt;br&gt;
**Sesión N° 4**&lt;br&gt;
02 octubre 2021&lt;br&gt;
**Análisis de datos estadísticos en R**
&lt;br&gt;

.pull-right.small[
**Profesora** Valentina Andrade de la Horra &lt;br&gt;
**Ayudantes** Dafne Jaime y Nicolás Godoy
.tiny[Universidad Alberto Hurtado&lt;br&gt;
]
]

]

---
class: title title-inv-8

# Contenidos Sesión 8

--

.box-2.medium.sp-after-half[**Diseño muestral complejo**]

--

.box-3.medium.sp-after-half[**El diseño muestral de CASEN 2020**]

--

.box-4.medium.sp-after-half[**Creación de objetos encuesta con srvyr**]

--

.box-5.medium.sp-after-half[**Estimación e inferencia**]

--

.box-6.medium.sp-after-half[**Creación de tabulado con las estimaciones**]

---
class: center middle main-title section-title-8 top-logo
name: basics

# 1: Flujo del Rproject

---
class: title title-inv-8

# Etapas del flujo

.center[
![:scale 70%](https://github.com/learn-R/slides/raw/main/img/01/flow-rproject.png)]

--

- *Hoy* nosotras/os nos centraremos en la parte de **análisis**.

---
class: title title-inv-8

# Orden de un script de análisis


.center[
![:scale 60%](https://raw.githubusercontent.com/learn-R/slides/main/img/04/orden-sintaxis.png)]

---
.center[
![](https://media2.giphy.com/media/ule4vhcY1xEKQ/giphy.gif)]

Figura 1: Estudiantes de Análisis de datos en R haciendo los **pasos 4 y 5.**
---
class: center middle main-title section-title-8 top-logo

# Paso 1: Cargar paquetes

---
layout: true
class: title title-8
---
# Paso 1: Cargar paquetes


```r
pacman::p_load(tidyverse, #Universo de paquetes
               sjmisc, #Para explorar datos
               srvyr, #Para trabajar con muestras complejas
               dplyr, #Para manipular datos
               tidyr) #Para transformar la estructura de los datos
```

---
layout: false
class: center middle section-title section-title-8 animated fadeIn

# Paso 2: Importar datos

---
# Consideraciones antes de importar datos 

Para **importar** los datos en R debemos tener en consideración tres cosas:

.can-edit.key-likes[
1.
2.
3.
]

---
# Consideraciones antes de importar datos 

Para **importar** los datos en R debemos tener en consideración tres cosas:

1. Cómo se llaman los datos (en nuestro caso casen_proc)

2. El formato de nuestros datos (en nuestro caso .rds)

3. El lugar de donde están alojados nuestros datos (en este caso, desde GitHub). 

---
# Paso 2: Importar datos


```r
data &lt;- readRDS(url("https://github.com/learn-R/07-class/blob/main/input/data/casen_proc.rds?raw=true"))
```

---
class: center middle main-title section-title-8 top-logo

# Como resultado

.large.box-inv-1[Nuevo objeto en el Enviroment]


---
class: center middle section-title section-title-8 animated fadeIn

# Paso 3: Explorar datos

---
class: center title title-8

# Explorar datos

¡Recordemos!

.box-inv-1[Para variables categóricas: `frq()`]

--

.box-inv-3[Para variables continuas: `descr()`]


--
En la tarea de explorar los datos, la librería `sjmisc` será nuestra mejor aliada
---
# Explorar datos para procesar


```r
## Variables categóricas

frq(data$region) #Examinamos la columna región
frq(data$pobreza) #Examinamos la columna pobreza
frq(data$sexo) #Examinamos la columna sexo
```
---
# Explorar datos para procesar


```r
## Variables continuas

descr(data$exp) #Ponderador regional
sum(data$exp) #Total de la población
descr(data$varstrat) #Estrato de varianza
descr(data$varunit) #Conglomerado de varianza
descr(data$ing_tot_hog) #Ingreso total del hogar
```
---
layout: false
class: center main-title section-title-8 top-logo

# ¡Continuemos con la creación del objeto encuesta!

---
layout: false
class: center middle main-title section-title-8 top-logo

# Pero antes...

---

# ¿Qué es un objeto encuesta?

.box-inv-1[Es una lista creada con la función 
`as_survey_design` de `srvyr`]

--

.box-inv-2[En este caso, la lista contiene 9 elemento diferentes]

--

.box-inv-3[Si bien su contenido es algo críptico, crear el 
objeto encuesta es crucial, pues nos permitirá trabajar con los datos como si fuese un dataframe]

---
class: center title title-8

# Creando el objeto encuesta


```r
obj_encuesta &lt;- data %&gt;% #Creamos un nuevo objeto encuesta con la información de nuestros datos
  as_survey_design(ids = conglomerado, #Aplicamos diseño muestral, especificando los ids a partir del conglomerado de varianza,
                   strata = estrato,#strat con los estratos de varianza,
                   fpc = nestrato, #especificando que la estimación está corregida con una población finita (cuando se pueda),
                   weights = ponderador) #y los ponderadores con weights
```

---
class:center title title-8

# ¿Por qué trabajar con objetos encuesta?

.box-inv-3[Los distintos argumentos especifican elementos del diseño muestral]

--

.box-inv-4[Así, podremos realizar estimaciones mucho más precisas]

--

.box-inv-5[Además de conocer el nivel de error de estas]

--

![:scale 25%](https://github.com/learn-R/slides/blob/main/img/04/kirby-cool.png?raw=true)

---
class: center title title-8

# Creando el objeto encuesta

En CASEN 2020 no viene incluida la variable fpc, por lo que debemos crearla


```r
data &lt;- data %&gt;% 
  group_by(varstrat) %&gt;% #Agrupando por varstrat
  mutate(stratn = sum(exp)) %&gt;% #Calculamos el total de personas por estrato
  ungroup() #¡No olvidemos desagrupar!
```

---
class: center title title-8

# Creando el objeto encuesta (¡por fin!)

En CASEN 2020 no viene incluida la variable fpc, por lo que debemos crearla


```r
casen_regional &lt;- data %&gt;% #Creamos un nuevo objeto llamado casen_regional con la información de data
  as_survey_design(ids = varunit, #Aplicamos diseño muestral, especificando los ids a partir de varunit,
                   strata = varstrat,#los estratos a partir de varstrat,
                   fpc = stratn, #especificando que la estimación es con una población finita
                   weights = exp) #y los ponderadores con exp
```

---
class: center title title-8

# Las ventajas de `srvyr`

.box-inv-5[Existen otras librerías que nos permiten crear objetos encuesta]

--

.box-inv-6[Sin embargo, nos quedamos con `srvyr`]

--

.box-inv-7[Dado que nos permite dialogar con librerías conocidas, como `dplyr`]

--

.box-inv-2[¡Sin considerar la simpleza de los cálculos!]
---
layout: false
class: center main-title section-title-8 top-logo

# ¡A calcular!

---
class: title title-8
# ¿Qué calcularemos?

- `srvyr` provee de muchas funciones para cálculos de diferentes estadísticos
- No obstante, aquí calcularemos **medias**, **proporciones** y **totales**

--

.box-inv-1[Son los estadísticos más usuales de reportar]

--

.box-inv-2[además de ser **insesgados**]

---
# Cálculo de medias `survey_mean()`


```r
## Cálculo simple
casen_regional %&gt;% #Con casen_regional
  summarize(ing_medio = srvyr::survey_mean(ing_tot_hog, na.rm=T)) #Calculamos el ingreso medio poblacional
```

---
# Comparamos con el cálculo a nivel muestral


```r
data %&gt;% #Con data
  summarise(ing_medio = mean(ing_tot_hog, na.rm=T)) #Calculamos el ingreso medio muestral
```

---

# Incorporamos Intervalos de Confianza al 95%


```r
casen_regional %&gt;%#Con casen_regional
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) #Calculamos el 
                                                                           #ingreso medio poblacional, 
                                                                           #y sus intervalos de confianza
```

--- 

# ¿Y si queremos otro nivel de confianza?


```r
casen_regional %&gt;% #Con casen_regional
  summarise(ing_medio95 = survey_mean(ing_tot_hog, vartype = "ci", level = .95, na.rm=T), #Al 95%
            ing_medio99 = survey_mean(ing_tot_hog, vartype = "ci", level = .99, na.rm=T)) #Al 99%
```

---
# Agrupamos por sexo (¡como con dplyr!)


```r
casen_regional %&gt;% #Con casen_regional
  group_by(sexo) %&gt;% #Agrupamos por sexo
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) #Calculamos el ingreso medio 
                                                                           #poblacional, y sus intervalos de 
                                                                           #confianza
```

---
# ¡Transformemos en wide con `tidyr`!


```r
ing_region &lt;- casen_regional %&gt;% 
  group_by(sexo) %&gt;% #Agrupamos por region
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) %&gt;% #Calculamos el ingreso medio poblacional, y sus intervalos de confianza
  select(sexo, ing_medio) %&gt;% #Seleccionamos region e ing_medio
  pivot_wider(names_from = "sexo", #Pivoteamos, extrayendo los nombres de las columnas desde region
              values_from = "ing_medio") #Y los valores desde ing_medio
```

---

# Cálculo de proporciones con `survey_prop()`

.box-inv-2[Una diferencia con `survey_mean()`: ¡Debemos agrupar por la(s) variable(s) categórica(s) de interés!]


```r
## Cálculo simple
casen_regional %&gt;% #Con casen_regional
  group_by(pobreza) %&gt;% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T)) #Y calculamos las proporciones
```

---
# Transformando a porcentaje (%) con `mutate()`


```r
## Transformando a porcentaje
casen_regional %&gt;% #Con casen_regional
  group_by(pobreza) %&gt;% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T))%&gt;% #Calculamos las proporciones
  mutate(per = prop*100) #Creamos una nueva columna multiplicando las proporciones *100 para obtener porcentajes
```

---
# Incorporamos los totales con `survey_total()`


```r
## Incorporamos cálculo de frecuencias
casen_regional %&gt;% #Con casen_regional
  group_by(pobreza) %&gt;% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T), #Calculamos las proporciones
            total = survey_total(na.rm=T))%&gt;% #Y el total por categorías
  mutate(per = prop*100) #Creamos una nueva columna multiplicando las proporciones *100 para obtener porcentajes
```

---
# Y los Intervalos de Confianza al 95%


```r
## Con Intervalos de confianza al 95%
casen_regional %&gt;% #Con casen_regional
  group_by(pobreza) %&gt;% #Agrupamos por pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T)) #Incorporamos intervalos de confianza
```

---
# ¡También podemos transformarlos en porcentajes!


```r
## Transformamos el estimador puntual y los límites del intervalo a porcentajes
## Incorporamos el total
casen_regional %&gt;% #Con casen_regional
  group_by(pobreza) %&gt;% #Agrupamos por pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %&gt;% #Así como el total por categoría
  mutate(prop = prop*100, #Multiplicamos las proporciones *100,
         prop_low = prop_low*100, #así como el límite inferior 
         prop_upp = prop_upp*100) #y superior, para obtener porcentajes
```

---
# Cruzamos variables


```r
## Cruzar dos variables
casen_regional %&gt;% #Creamos un objeto llamado pobreza_reg con datos de casen_regional
  group_by(pobreza, sexo) %&gt;% #Agrupamos por pobreza y sexo
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %&gt;% #Así como el total por categoría
  mutate(prop = prop*100)
```

---
# ¡Transformemos en wide con `tidyr`!


```r
## Crear objeto wide
pobreza_reg &lt;- casen_regional %&gt;% #Creamos un objeto llamado pobreza_reg con datos de casen_regional
  group_by(region, pobreza) %&gt;% #Agrupamos por region y pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %&gt;% #Así como el total por categoría
  mutate(per = prop*100) %&gt;% #Multiplicamos las proporciones *100 para obtener porcentajes
  select(region, pobreza, per, total) %&gt;% #Seleccionamos region, pobreza, per y total
  pivot_wider(names_from = "pobreza", #Pivoteamos a lo ancho, extrayendo los nombres de las columnas desde pobreza
              values_from = c("per", "total")) #y los valores desde per y total
```

---
class: title title-2

# 1. Recursos de la práctica

- Datos: *Encuesta de Caracterización Socioeconómica (CASEN)* (2020).

- Para ello, deben dirigirse al [siguiente enlace](https://drive.google.com/drive/folders/1Orgb3Qb9LcjTfjYMdIdy7SWd3xDMrTbG?usp=sharing) y descargar los zip.


- [**Libro de códigos**](http://observatorio.ministeriodesarrollosocial.gob.cl/storage/docs/casen/2020/Libro_de_codigos_Base_de_Datos_Casen_en_Pandemia_2020.pdf) antes de trabajar una base de datos.

---
layout: false
class: center middle section-title-2 top-logo

# Al explorar nuestros datos

--

# Pudimos notar cierta información sobre las columnas que de a poco debemos asimilar

---
layout: true
class: title title-2
---

# Tipos de datos

--

- Las que principalmente nos interesarán son los "vectores"

--

- En nuestro "idioma", son las **variables**.
--

- En general, una combinación de vectores da origen a una matriz (o **data frame** o "base de datos" [^1])

[^1]: *Un error omitido por muchas/os* 

---
# Tipos de datos: columnas

Relación entre clase y nivel de medición de la variable

- `numeric`

- `character`

- `factor`

- hay varios más...

---
# Operadores

- Símbolos que no son de uso exclusivo en R ¡probablemente los conoces desde tus cursos de matemática! (*la suma, la resta*)

- Ahora bien, no todos tienen el mismo significado que en otros softwares.

- Tendrán distintos objetivos: relacionar, condicionar, excluir, repetir etc. Lo importante: buscan darle un **sentido** a la "orden" que le estamos dando a R.

- Los utilizaremos cuando **filtremos** nuestros datos para personas de ciertas categorías, cuando **calculemos variables** nuevas (de manera aritmética o condicional) o, simplemente, cuando queramos hacer procesos "concatenados".

---
class: title title-2

# Operadores relacionales 

Se usan para hacer comparaciones. Cuando en la *Tabla 1* nos referimos a `un valor`, esto refiere tambien a `variables`

| Símbolo  | Función |
|---------:|:--------|
| `&lt;`      |  Un valor es menor que otro |
| `&gt;`      |  Un valor es mayor que otro |
| `==`     |  Un valor es igual que otro [^1] |
| `&lt;=`     |  Un valor es menor o igual que otro |
| `&gt;=`     |  Un valor es mayor o igual que otro |
| `!=`     |  Un valor es distinto o diferente que otro|
| `%in%`   |  Un valor pertenece al conjunto designado [^2] |
| `is.na()`|  El valor es perdido o `NA` |
| `!is.na()`| El valor es distinto de  `NA` |

---
# Tips

- ¡Atención! Fíjate bien que `==` y `=` son distintos. En R `==` es indicar *"igual a"*, mientras que  `=` es *asignar* (sinónimo de `&lt;-`)

- El operador `%in%` es **muy utilizado**, sirve para indicar que algo está dentro de una cadena de valores. 

---
# Operadores aritméticos

Realizan operaciones, como la suma, resta, división, entre otros.

| Símbolo  | Función |
|---------:|:--------|
| `+`      |  Suma |
| `-`      |  Resta|
| `*`     |  Multiplicación |
| `/`     |  División |
| `^`     |  Elevado |

---

# Operadores de asignación

Hay dos formas de asignar:

- `objetoA &lt;- objetoB`
- `objetoA = objetoB`.

Ambas implican que lo que se este realizando en el *objetoB* implica que eso va a producir o generar al *objetoA*.

La diferencia está en que la segunda opción es más utilizada dentro de las funciones pues su significado más bien es *"es"*

---

# Operadores booleanos

Describen relaciones **lógicas** o **condicionales**

| Símbolo  | Función |
|---------:|:--------|
| `&amp;`      |  Indica un *y* lógico |
| `"|"`      |  Indica un *o* lógico |
| `xor()`  |  Excluye la condición  |
| `!`      |  Distinto de ... |
| `any`    |  Ninguna de las condiciones serán utilizadas |
| `all`    |  Todas las condiciones serán ocupadas |


---

# Resumen

![](https://github.com/learn-R/slides/raw/main/img/02/01operad.png)

Figura 1: Resumen de operadores

---
layout: false
class: center middle section-title-2 top-logo

# Redoble de tambores, el más importante de la fiesta 🥁

---
layout: true
class: title title-2

---
# Operador pipeline %&gt;% 

- `%&gt;%` (llamado `pipe`) no es un operador que esté contenido en las funciones base del lenguaje R (origen `magrittr` de `tidyverse`)

- Es de los operadores **más útiles y utilizados** en R.

--

**En el teclado**

- `Ctrl + shift + M` Para Windows
- `⌘ + shift + M` Para Mac


---
# Operador pipeline %&gt;% 

- Función: **concatenar** múltiples funciones y procesos.

--

- ¿Cómo es eso? 🤨

--
- ¡Tranquila/o! Ya lo veremos 🧘🏽‍♂️

---

# ¡Ya queremos ir a practicar! 🏃🏽‍♀️🏃🏽

---

# Transformación y selección de variables con `dplyr()`

--

1.  `select()` para seleccionar variables

--

2.  `filter()` para filtrar observaciones

--

3. `mutate()` crear nuevas variables
  
  -  `recode()`, `if_else()`, `case_when()`

---

# `select()` para manipular variables

- Para **seleccionar variables** ocuparemos `select()`.

--

Si queremos incluir las variables `variable1`, `variable2` y `variable3`

```r
select(datos, variable1, variable2, variable3)
```

--
Si queremos excluir anteponemos un menos `-variable1`


```r
select(datos, -variable1)
```

---
# Formas de hacer `select()`

1. Por indexación


```r
select(datos, 1,2) # la primera y la segunda columna
select(datos, 1:4) # la primera hasta la cuarta columna
```

2. por nombre de columna


```r
select(datos, edad, sexo, o1)
```

---
# Trucos de `select()`

1. Renombrar en el mismo proceso de selección indicando `nuevo_nombre = nombre_original` en el proceso de selección


```r
select(datos, edad, sexo, ocupacion = o1)
```

2. Reordenar variables

- `everything()` nos indica que ponga "todo el resto".


```r
select(datos, id_persona, sexo, edad, everything())
```

---

# Formas de hacer `select()`

3. Con patrones de texto: prefijos, sufijos o partes de *cómo están nombradas las variables*.

- Poner textos y expresiones regulares entre **comillas**.

- `starts_with()`: prefijo 
- `ends_with() `:  sufijo
- `contains()` : contiene una cadena de texto literal
- `matches()` : coincide con una expresión regular

---
# Formas de hacer `select()`


```r
select(datos, starts_with("a"), ends_with("preg"))

# También se pueden combinar con operadores logicos

select(datos, starts_with("y1")&amp;ends_with("preg")) 
select(datos, contains("pobre")|contains("vivienda"))
select(datos, matches("pobreza_|vivienda"))
```

---
# Formas de hacer `select()`

4. Con condiciones lógicas

- `select()` + `where()`:  *"seleciona donde"*, ese *donde* responde a una condición que cumple cierta variable.

- Por ejemplo, queremos seleccionar todas las variables que son carácteres (`is.character`):


```r
select(datos, where(is.character))
```

---
layout: false

- Luego de la exploración de datos mediante a funciones como `find_var()` de `sjmisc` decidimos trabajar con las siguientes variables.

- `edad`
- `sexo`
- `s13`: previsión de salud
- `tot_per`: número de personas en el hogar
- `ytoth`: ingresos totales del hogar
- `o1`: ocupación
- `y26d_total`: Monto del IFE
- `y26d_hog`: ¿Alguien recibió el IFE?

¡Apliquémos conocimientos!


```r
select(datos, edad, sexo, prev =592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&amp;matches("total|hog"))
```

---
layout: true
class: title title-4
---
# Nuevo data set

- Buena práctica trabajar solo con las columnas que utilizaremos para el análisis, principalmente pues disminuye el *uso de memoria*


```r
datos_proc &lt;- select(datos, edad, sexo, prev = 592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&amp;matches("total|hog"))
```

---

# ¡Ejercicio en grupos!

--

- Seleccionen una variable de nivel educacional, region, sexo, la variable 700 y todas las que refieran a ingresos.

- Indiquen cómo hicieron ese procedimiento

- Con estos cambios, creen un nuevo objeto llamado `ejercicio`

---


# ¿Qué pasa si quiero trabajar con un *subset* de casos?

--

# La respuesta es `filter()`

---

# `filter()` para manipular observaciones

- La función `filter()` de `dplyr` escoge o extrae filas basados en sus valores, subdivide un data frame (*subset*)

- Uso de los **operadores**

--


```r
filter(datos, condicion_para filtrar)
```

Imaginemos que queremos filtrar valores mayores o iguales 3 **respecto a la variable1**


```r
filter(datos, variable1 &gt;= 3)
```

---
# Formas de `filter()`

1. Con números

Imaginémos que queremos una base con las personas mayores de 15 años. 

```r
filter(datos_proc, edad &gt;= 15)
filter(datos_proc, edad &gt;= 15 &amp; tot_per &lt;7)
```

--

Pero también que pertenezcan a hogares con menos de 7 personas. 

```r
filter(datos_proc, edad &gt;= 15 &amp; tot_per &lt;7)
```

---
# Formas de `filter()`

2. Con carácteres

- Importancia de explorar los datos
  1. Fijarse bien cómo están escritos
  2. Clase (ver si efectivamente son carácteres)

- R es *sensible* a cómo está escrito el texto (*key sensitive*)

---
# Truco

- Cuando haya problemas aplicar `as_factor()` que permite conservar los niveles pero definiendo sus categorías de respuesta en base a la etiqueta que traen (el `lbl`)

- Consejo útil sobre todo en bases que provienen de SPSS y STATA

---
# Formas de `filter()`


```r
datos_proc$sexo &lt;- as_factor(datos_proc$sexo)
```


```r
filter(datos_proc, sexo == "Mujer")
filter(datos_proc, sexo != "Hombre")
```

---
# Un clásico, y la solución: %in%

- ¿Cómo se seleccionan dos condiciones en carácter? Con el operador `%in%`


```r
datos_proc$prev &lt;- as_factor(datos_proc$prev)

filter(datos_proc, prev %in% c("Sistema Público FONASA", "ISAPRE"))
```

---
# Ejercicio

- Con su data frame `ejercicio` filtren
  - Excluyan a las personas sin estudios
  - Filtren a la persona con máximos ingresos del hogar
  - Conserven a las personas de la RM y Valparaíso. 

---
class: center middle section-title-4 top-logo

# ¿Y si quiero crear variables nuevas?

--

.box-5[`mutate()`]
---

# `mutate()` para transformación de  variables

- `mutate()` permite hacer operaciones para crear nuevas variables o transformar las ya existentes. 


```r
mutate(datos, nueva_variable = cálculo o condición)
```

---
# Formas de hacer `mutate()`

1. En base a cálculo


```r
mutate(datos_proc, nueva_variable = 3+2)
mutate(datos_proc, nueva_variable = 3+2,
       ingreso_percapita = ytoth/tot_per)
```

---
class: center middle section-title-4 top-logo

# Aquí mucha mucha atención...

--

# Viene la aplicación de  %&gt;%

.box-inv-4[¿Qué pasa si queremos, luego de calcular nuestras nuevas variables, filtrar un ingreso per cápita menor o igual a $1.000.000]

---
# `%&gt;%`


```r
datos %&gt;% 
  mutate(., nueva_variable = calculo ) %&gt;% 
  filter(., nueva_variable &lt;= valor)
```

--

- Básicamente, el ` %&gt;% ` permite "ingresar" nuestra base de datos como argumento para cada función e ir operándola en proceso

---
# `%&gt;%` 


```r
datos_proc %&gt;%
  mutate(ingreso_percapita = ytoth/tot_per) %&gt;% 
  filter(ingreso_percapita &lt;= 1000000)
```
--
 
**En el teclado**

- `Ctrl + shift + M` Para Windows
- `⌘ + shift + M` Para Mac

---
layout: false
class: center middle section-title-5 top-logo

# Crear nuevas variables utilizando *además* otras funciones

--

## mutate(variable_nueva = alguna_funcion_genial)


---
layout: true
class: title title-5

# Opciones para recodificar.

- `dplyr::recode()` y  `car::recode()` 

- Con `dplyr::recode()`: recodificamos las categorías de respuesta de Mujer a Femenino y de Hombre a Masculino


```r
datos_proc %&gt;% 
  mutate(sexo = dplyr::recode(sexo, "Mujer" = "Femenino", "Hombre" = "Masculino"))
```

- El problema de `recode()` que se utiliza dentro de `dplyr` es que si recodifico se pierde la etiqueta anterior.

---
# Mi elección: `car::recode()`

- **No olviden** los `::` por los posibles conflictos


```r
car::recode(datos$variable, c('valor_orig1=nuevo_valor1;valor_org2=nuevo_valor2'))
```

---
# Mi elección: `car::recode()`


```r
datos_proc %$% 
  car::recode(.$y26d_hog, c('9=NA')) %&gt;% head(.)
```

Aquí una versión de si la recodificación es hacia carácteres (mismo ejemplo que con `recode()` de `dplyr`)


```r
datos_proc %$% 
  car::recode(.$sexo,
              c('"Mujer"="Femenino";"Hombre"= "Masculino"'),
              as.factor = T) %&gt;% head(.)
```

---
.small[
# `if_else()` variables condicionales
]

La función `if_else()` permite construir variables en base a condiciones lógicas. Su estructura es la siguiente


```r
if_else(condición,TRUE,FALSE)
```


---
.small[
# `if_else()`  variables condicionales
]
Crearemos una variable que *dummy* que indica si el respondente es *FONASA* o no lo es. 


```r
datos_proc %&gt;% 
 		 mutate(fonasa = if_else(prev == "Sistema Público FONASA", 1, 0))
```

---
.small[
# `if_else()` variables condicionales
]
- Uno/a puede ser *ingenioso* y ocuparla como **validador**


```r
datos_proc %&gt;% 
  mutate(validador_ingreso = if_else(is.na(ytoth), FALSE, TRUE))
```

- También para *imputar valores* ¿cómo sería?

---
.small[
# `case_when()`  variables con múltiples condiciones
]
- Para *colapsar* categorías o construir categorías en base a varias condiciones es `case_when()` por lo lógico y *fácil* que es de entender


```r
case_when(variable == condicion ~ valor1,
          variable == condicion ~ valor2,
          TRUE ~ NA_real)
```

- Donde, TRUE indica "todo el resto", y el NA dependerá de la clase del valor de recodificación

---
.small[
# `case_when()` variables con múltiples condiciones
]
Un ejemplo claro es cuando queremos construir *categorías de edad*


```r
datos_proc %&gt;% 
  mutate(edad_tramo = case_when(edad &lt;=39 ~  "Joven",
                                edad &gt; 39 &amp; edad &lt;=59 ~ "Adulto",
                                edad &gt; 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_)) %&gt;% 
  select(edad, edad_tramo)
```

- ¡Utilizamos operadores lógicos (`&amp;`)!


---
# ¡Resumen!

```r
datos_proc %&gt;% 
 filter(edad &gt;= 15 &amp; tot_per &lt;7) %&gt;%
    mutate(ingreso_percapita = ytoth/tot_per,
           edad_tramo = case_when(edad &lt;=39 ~  "Joven",
                                edad &gt; 39 &amp; edad &lt;=59 ~ "Adulto",
                                edad &gt; 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_),
           fonasa = if_else(prev == "Sistema Público FONASA", 1, 0),
           ocupacion = as_factor(ocupacion)) %&gt;%
  select(sexo, edad_tramo, ocupacion, ingreso_percapita, ife = y26d_hog)
```

---
# ¡Resumen!
¡Ahora que estamos seguras/os sobre-escribimos la base!

```r
datos_proc &lt;- datos_proc %&gt;% 
 filter(edad &gt;= 15 &amp; tot_per &lt;7) %&gt;%
    mutate(ingreso_percapita = ytoth/tot_per,
           edad_tramo = case_when(edad &lt;=39 ~  "Joven",
                                edad &gt; 39 &amp; edad &lt;=59 ~ "Adulto",
                                edad &gt; 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_),
           fonasa = if_else(prev == "Sistema Público FONASA", 1, 0),
           ocupacion = as_factor(ocupacion)) %&gt;%
  select(sexo, edad_tramo, ocupacion, ingreso_percapita, ife = y26d_hog)
```

---
# Antes de guardar

Podemos visualizar la base resultante a partir de `view_df()` de `sjPlot`

```r
sjPlot::view_df(datos_proc)
```

---
# Paso 4: Guardar datos

Para guardar la base de datos procesada, debes dirigir la ruta hacia tu Rproject


```r
saveRDS(datos_proc, file = "../nombre_project/output/datos_proc.rds")
```

- Recuerda revisar el [practico N°2](example/02-practico) si no recuerdas como expoertar datos.

---
layout: false
class: center section-title section-title-5 animated fadeIn

# En síntesis

.box-2.medium.sp-after-half[**Básicos en manipulación**]
.small.box-2[Operadores y tipos de datos]

--

.box-3.medium.sp-after-half[**Seleccionar variables**]

--

.box-4.medium.sp-after-half[**Filtrar**]

--

.box-5.medium.sp-after-half[**Crear variables**]

---
class: center middle main-title section-title-4 top-logo

# ¡Y a no olvidar el flujo para el análisis!

--

## Nos permite hacernos amigas/os más rápido del programa
---

.center[
![:scale 80%](https://github.com/learn-R/slides/raw/main/img/01/flow-rproject.png)]

---
layout: false

.box-1[¿Y eso era?]

--

.box-inv-1[¡Ahora si que si! Nos vemos el próximo viernes en la última sesión]

.center[
![](https://github.com/learn-R/slides/raw/main/img/01/monster-inc-2.gif)]
---
layout: false
class: center middle main-title section-title-1 top-logo

.small[
# Muestras complejas y precisión de inferencia estadística
]

.class-info[
&lt;br&gt;
**Sesión N° 4**&lt;br&gt;
02 octubre 2021&lt;br&gt;
**Análisis de datos estadísticos en R**
&lt;br&gt;

.pull-right.small[
**Profesora** Valentina Andrade de la Horra &lt;br&gt;
**Ayudantes** Dafne Jaime y Nicolás Godoy
.tiny[Universidad Alberto Hurtado&lt;br&gt;
]
]

]

???
https://c.tenor.com/7mxJp29REVkAAAAC/scaryfeet-monstersinc.gif
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script src="libs/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"navigation": {
"scroll": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url("../img/logo.png");
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 110px;
  height: 128px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
