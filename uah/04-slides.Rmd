---
title: "Análisis de datos estadísticos en R"
author: "Valentina Andrade y Nicolás Godoy"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    self_contained: true
    lib_dir: "libs"
    chakra: "libs/remark-latest.min.js"
    css: ["default", "css/ath-slides.css", "css/ath-inferno-fonts.css", "css/animate.css"]
    seal: false
    includes:
      after_body: "html/insert-logo.html"
    anchor_sections: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      beforeInit: "libs/macros.js"
      navigation:
        scroll: false
editor_options: 
  chunk_output_type: console
---


```{r packages-data, include=FALSE}
pacman::p_load(tidyverse, sjPlot, ggsci, wordcloud2)
theme_set(theme_sjplot2())

```
```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view", "animate_css", "share_again", "scribble", "frezeeframe", "editable", "progress_bar"))

xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         #<<
  mute_unhighlighted_code = TRUE  #<<
)
```


```{r xaringanExtra-clipboard, echo=FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clipboard\">Copiar código</i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\">¡Listo!</i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, eval = F, 
                      fig.retina = 3, fig.align = "center")
```

class: center middle main-title section-title-1 top-logo

.small[
# Muestras complejas y precisión de inferencia estadística
]

.class-info[
<br>
**Sesión N° 4**<br>
`r format(Sys.Date(), '%d %B %Y')`<br>
**Análisis de datos estadísticos en R**
<br>

.pull-right.small[
**Profesora** Valentina Andrade de la Horra <br>
**Ayudantes** Dafne Jaime y Nicolás Godoy
.tiny[Universidad Alberto Hurtado<br>
]
]

]

---
class: title title-inv-8

# Contenidos Sesión 8

--

.box-2.medium.sp-after-half[**Diseño muestral complejo**]

--

.box-3.medium.sp-after-half[**El diseño muestral de CASEN 2020**]

--

.box-4.medium.sp-after-half[**Creación de objetos encuesta con srvyr**]

--

.box-5.medium.sp-after-half[**Estimación e inferencia**]

--

.box-6.medium.sp-after-half[**Creación de tabulado con las estimaciones**]

---
class: center middle main-title section-title-8 top-logo
name: basics

# 1: Flujo del Rproject

---
class: title title-inv-8

# Etapas del flujo

.center[
![:scale 70%](https://github.com/learn-R/slides/raw/main/img/01/flow-rproject.png)]

--

- *Hoy* nosotras/os nos centraremos en la parte de **análisis**.

---
class: title title-inv-8

# Orden de un script de análisis


.center[
![:scale 60%](https://raw.githubusercontent.com/learn-R/slides/main/img/04/orden-sintaxis.png)]

---
.center[
![](https://media2.giphy.com/media/ule4vhcY1xEKQ/giphy.gif)]

Figura 1: Estudiantes de Análisis de datos en R haciendo los **pasos 4 y 5.**
---
class: center middle main-title section-title-8 top-logo

# Paso 1: Cargar paquetes

---
layout: true
class: title title-8
---
# Paso 1: Cargar paquetes

```{r}
pacman::p_load(tidyverse, #Universo de paquetes
               sjmisc, #Para explorar datos
               srvyr, #Para trabajar con muestras complejas
               dplyr, #Para manipular datos
               tidyr) #Para transformar la estructura de los datos
```

---
layout: false
class: center middle section-title section-title-8 animated fadeIn

# Paso 2: Importar datos

---
# Consideraciones antes de importar datos 

Para **importar** los datos en R debemos tener en consideración tres cosas:

.can-edit.key-likes[
1.
2.
3.
]

---
# Consideraciones antes de importar datos 

Para **importar** los datos en R debemos tener en consideración tres cosas:

1. Cómo se llaman los datos (en nuestro caso casen_proc)

2. El formato de nuestros datos (en nuestro caso .rds)

3. El lugar de donde están alojados nuestros datos (en este caso, desde GitHub). 

---
# Paso 2: Importar datos

```{r eval=FALSE, include=TRUE}
data <- readRDS(url("https://github.com/learn-R/07-class/blob/main/input/data/casen_proc.rds?raw=true"))
```

---
class: center middle main-title section-title-8 top-logo

# Como resultado

.large.box-inv-1[Nuevo objeto en el Enviroment]


---
class: center middle section-title section-title-8 animated fadeIn

# Paso 3: Explorar datos

---
class: center title title-8

# Explorar datos

¡Recordemos!

.box-inv-1[Para variables categóricas: `frq()`]

--

.box-inv-3[Para variables continuas: `descr()`]


--
En la tarea de explorar los datos, la librería `sjmisc` será nuestra mejor aliada
---
# Explorar datos para procesar

```{r eval=FALSE, include=TRUE}

## Variables categóricas

frq(data$region) #Examinamos la columna región
frq(data$pobreza) #Examinamos la columna pobreza
frq(data$sexo) #Examinamos la columna sexo

```
---
# Explorar datos para procesar

```{r eval=FALSE, include=TRUE}

## Variables continuas

descr(data$exp) #Ponderador regional
sum(data$exp) #Total de la población
descr(data$varstrat) #Estrato de varianza
descr(data$varunit) #Conglomerado de varianza
descr(data$ing_tot_hog) #Ingreso total del hogar

```
---
layout: false
class: center main-title section-title-8 top-logo

# ¡Continuemos con la creación del objeto encuesta!

---
layout: false
class: center middle main-title section-title-8 top-logo

# Pero antes...

---

# ¿Qué es un objeto encuesta?

.box-inv-1[Es una lista creada con la función 
`as_survey_design` de `srvyr`]

--

.box-inv-2[En este caso, la lista contiene 9 elemento diferentes]

--

.box-inv-3[Si bien su contenido es algo críptico, crear el 
objeto encuesta es crucial, pues nos permitirá trabajar con los datos como si fuese un dataframe]

---
class: center title title-8

# Creando el objeto encuesta

```{r}
obj_encuesta <- data %>% #Creamos un nuevo objeto encuesta con la información de nuestros datos
  as_survey_design(ids = conglomerado, #Aplicamos diseño muestral, especificando los ids a partir del conglomerado de varianza,
                   strata = estrato,#strat con los estratos de varianza,
                   fpc = nestrato, #especificando que la estimación está corregida con una población finita (cuando se pueda),
                   weights = ponderador) #y los ponderadores con weights
```

---
class:center title title-8

# ¿Por qué trabajar con objetos encuesta?

.box-inv-3[Los distintos argumentos especifican elementos del diseño muestral]

--

.box-inv-4[Así, podremos realizar estimaciones mucho más precisas]

--

.box-inv-5[Además de conocer el nivel de error de estas]

--

![:scale 25%](https://github.com/learn-R/slides/blob/main/img/04/kirby-cool.png?raw=true)

---
class: center title title-8

# Creando el objeto encuesta

En CASEN 2020 no viene incluida la variable fpc, por lo que debemos crearla

```{r}
data <- data %>% 
  group_by(varstrat) %>% #Agrupando por varstrat
  mutate(stratn = sum(exp)) %>% #Calculamos el total de personas por estrato
  ungroup() #¡No olvidemos desagrupar!
```

---
class: center title title-8

# Creando el objeto encuesta (¡por fin!)

En CASEN 2020 no viene incluida la variable fpc, por lo que debemos crearla

```{r}
casen_regional <- data %>% #Creamos un nuevo objeto llamado casen_regional con la información de data
  as_survey_design(ids = varunit, #Aplicamos diseño muestral, especificando los ids a partir de varunit,
                   strata = varstrat,#los estratos a partir de varstrat,
                   fpc = stratn, #especificando que la estimación es con una población finita
                   weights = exp) #y los ponderadores con exp
```

---
class: center title title-8

# Las ventajas de `srvyr`

.box-inv-5[Existen otras librerías que nos permiten crear objetos encuesta]

--

.box-inv-6[Sin embargo, nos quedamos con `srvyr`]

--

.box-inv-7[Dado que nos permite dialogar con librerías conocidas, como `dplyr`]

--

.box-inv-2[¡Sin considerar la simpleza de los cálculos!]
---
layout: false
class: center main-title section-title-8 top-logo

# ¡A calcular!

---
class: title title-8
# ¿Qué calcularemos?

- `srvyr` provee de muchas funciones para cálculos de diferentes estadísticos
- No obstante, aquí calcularemos **medias**, **proporciones** y **totales**

--

.box-inv-1[Son los estadísticos más usuales de reportar]

--

.box-inv-2[además de ser **insesgados**]

---
# Cálculo de medias `survey_mean()`

```{r}
## Cálculo simple
casen_regional %>% #Con casen_regional
  summarize(ing_medio = srvyr::survey_mean(ing_tot_hog, na.rm=T)) #Calculamos el ingreso medio poblacional
```

---
# Comparamos con el cálculo a nivel muestral

```{r}
data %>% #Con data
  summarise(ing_medio = mean(ing_tot_hog, na.rm=T)) #Calculamos el ingreso medio muestral
```

---

# Incorporamos Intervalos de Confianza al 95%

```{r}
casen_regional %>%#Con casen_regional
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) #Calculamos el 
                                                                           #ingreso medio poblacional, 
                                                                           #y sus intervalos de confianza
```

--- 

# ¿Y si queremos otro nivel de confianza?

```{r}
casen_regional %>% #Con casen_regional
  summarise(ing_medio95 = survey_mean(ing_tot_hog, vartype = "ci", level = .95, na.rm=T), #Al 95%
            ing_medio99 = survey_mean(ing_tot_hog, vartype = "ci", level = .99, na.rm=T)) #Al 99%
```

---
# Agrupamos por sexo (¡como con dplyr!)

```{r}
casen_regional %>% #Con casen_regional
  group_by(sexo) %>% #Agrupamos por sexo
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) #Calculamos el ingreso medio 
                                                                           #poblacional, y sus intervalos de 
                                                                           #confianza
```

---
# ¡Transformemos en wide con `tidyr`!

```{r}
ing_region <- casen_regional %>% 
  group_by(sexo) %>% #Agrupamos por region
  summarise(ing_medio = survey_mean(ing_tot_hog, vartype = "ci", na.rm=T)) %>% #Calculamos el ingreso medio poblacional, y sus intervalos de confianza
  select(sexo, ing_medio) %>% #Seleccionamos region e ing_medio
  pivot_wider(names_from = "sexo", #Pivoteamos, extrayendo los nombres de las columnas desde region
              values_from = "ing_medio") #Y los valores desde ing_medio
```

---

# Cálculo de proporciones con `survey_prop()`

.box-inv-2[Una diferencia con `survey_mean()`: ¡Debemos agrupar por la(s) variable(s) categórica(s) de interés!]

```{r}
## Cálculo simple
casen_regional %>% #Con casen_regional
  group_by(pobreza) %>% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T)) #Y calculamos las proporciones
```

---
# Transformando a porcentaje (%) con `mutate()`

```{r}
## Transformando a porcentaje
casen_regional %>% #Con casen_regional
  group_by(pobreza) %>% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T))%>% #Calculamos las proporciones
  mutate(per = prop*100) #Creamos una nueva columna multiplicando las proporciones *100 para obtener porcentajes
```

---
# Incorporamos los totales con `survey_total()`

```{r}
## Incorporamos cálculo de frecuencias
casen_regional %>% #Con casen_regional
  group_by(pobreza) %>% #Agrupamos por pobreza
  summarise(prop = survey_prop(na.rm = T), #Calculamos las proporciones
            total = survey_total(na.rm=T))%>% #Y el total por categorías
  mutate(per = prop*100) #Creamos una nueva columna multiplicando las proporciones *100 para obtener porcentajes
```

---
# Y los Intervalos de Confianza al 95%

```{r}
## Con Intervalos de confianza al 95%
casen_regional %>% #Con casen_regional
  group_by(pobreza) %>% #Agrupamos por pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T)) #Incorporamos intervalos de confianza
```

---
# ¡También podemos transformarlos en porcentajes!

```{r}
## Transformamos el estimador puntual y los límites del intervalo a porcentajes
## Incorporamos el total
casen_regional %>% #Con casen_regional
  group_by(pobreza) %>% #Agrupamos por pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %>% #Así como el total por categoría
  mutate(prop = prop*100, #Multiplicamos las proporciones *100,
         prop_low = prop_low*100, #así como el límite inferior 
         prop_upp = prop_upp*100) #y superior, para obtener porcentajes
```

---
# Cruzamos variables

```{r}
## Cruzar dos variables
casen_regional %>% #Creamos un objeto llamado pobreza_reg con datos de casen_regional
  group_by(pobreza, sexo) %>% #Agrupamos por pobreza y sexo
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %>% #Así como el total por categoría
  mutate(prop = prop*100)
```

---
# ¡Transformemos en wide con `tidyr`!

```{r}
## Crear objeto wide
pobreza_reg <- casen_regional %>% #Creamos un objeto llamado pobreza_reg con datos de casen_regional
  group_by(region, pobreza) %>% #Agrupamos por region y pobreza
  summarise(prop = survey_prop(vartype = "ci", na.rm = T), #Calculamos las proporciones con intervalos de confianza
            total = survey_total(vartype = "ci", na.rm=T)) %>% #Así como el total por categoría
  mutate(per = prop*100) %>% #Multiplicamos las proporciones *100 para obtener porcentajes
  select(region, pobreza, per, total) %>% #Seleccionamos region, pobreza, per y total
  pivot_wider(names_from = "pobreza", #Pivoteamos a lo ancho, extrayendo los nombres de las columnas desde pobreza
              values_from = c("per", "total")) #y los valores desde per y total
```

---
class: title title-2

# 1. Recursos de la práctica

- Datos: *Encuesta de Caracterización Socioeconómica (CASEN)* (2020).

- Para ello, deben dirigirse al [siguiente enlace](https://drive.google.com/drive/folders/1Orgb3Qb9LcjTfjYMdIdy7SWd3xDMrTbG?usp=sharing) y descargar los zip.


- [**Libro de códigos**](http://observatorio.ministeriodesarrollosocial.gob.cl/storage/docs/casen/2020/Libro_de_codigos_Base_de_Datos_Casen_en_Pandemia_2020.pdf) antes de trabajar una base de datos.

---
layout: false
class: center middle section-title-2 top-logo

# Al explorar nuestros datos

--

# Pudimos notar cierta información sobre las columnas que de a poco debemos asimilar

---
layout: true
class: title title-2
---

# Tipos de datos

--

- Las que principalmente nos interesarán son los "vectores"

--

- En nuestro "idioma", son las **variables**.
--

- En general, una combinación de vectores da origen a una matriz (o **data frame** o "base de datos" [^1])

[^1]: *Un error omitido por muchas/os* 

---
# Tipos de datos: columnas

Relación entre clase y nivel de medición de la variable

- `numeric`

- `character`

- `factor`

- hay varios más...

---
# Operadores

- Símbolos que no son de uso exclusivo en R ¡probablemente los conoces desde tus cursos de matemática! (*la suma, la resta*)

- Ahora bien, no todos tienen el mismo significado que en otros softwares.

- Tendrán distintos objetivos: relacionar, condicionar, excluir, repetir etc. Lo importante: buscan darle un **sentido** a la "orden" que le estamos dando a R.

- Los utilizaremos cuando **filtremos** nuestros datos para personas de ciertas categorías, cuando **calculemos variables** nuevas (de manera aritmética o condicional) o, simplemente, cuando queramos hacer procesos "concatenados".

---
class: title title-2

# Operadores relacionales 

Se usan para hacer comparaciones. Cuando en la *Tabla 1* nos referimos a `un valor`, esto refiere tambien a `variables`

| Símbolo  | Función |
|---------:|:--------|
| `<`      |  Un valor es menor que otro |
| `>`      |  Un valor es mayor que otro |
| `==`     |  Un valor es igual que otro [^1] |
| `<=`     |  Un valor es menor o igual que otro |
| `>=`     |  Un valor es mayor o igual que otro |
| `!=`     |  Un valor es distinto o diferente que otro|
| `%in%`   |  Un valor pertenece al conjunto designado [^2] |
| `is.na()`|  El valor es perdido o `NA` |
| `!is.na()`| El valor es distinto de  `NA` |

---
# Tips

- ¡Atención! Fíjate bien que `==` y `=` son distintos. En R `==` es indicar *"igual a"*, mientras que  `=` es *asignar* (sinónimo de `<-`)

- El operador `%in%` es **muy utilizado**, sirve para indicar que algo está dentro de una cadena de valores. 

---
# Operadores aritméticos

Realizan operaciones, como la suma, resta, división, entre otros.

| Símbolo  | Función |
|---------:|:--------|
| `+`      |  Suma |
| `-`      |  Resta|
| `*`     |  Multiplicación |
| `/`     |  División |
| `^`     |  Elevado |

---

# Operadores de asignación

Hay dos formas de asignar:

- `objetoA <- objetoB`
- `objetoA = objetoB`.

Ambas implican que lo que se este realizando en el *objetoB* implica que eso va a producir o generar al *objetoA*.

La diferencia está en que la segunda opción es más utilizada dentro de las funciones pues su significado más bien es *"es"*

---

# Operadores booleanos

Describen relaciones **lógicas** o **condicionales**

| Símbolo  | Función |
|---------:|:--------|
| `&`      |  Indica un *y* lógico |
| `"|"`      |  Indica un *o* lógico |
| `xor()`  |  Excluye la condición  |
| `!`      |  Distinto de ... |
| `any`    |  Ninguna de las condiciones serán utilizadas |
| `all`    |  Todas las condiciones serán ocupadas |


---

# Resumen

![](https://github.com/learn-R/slides/raw/main/img/02/01operad.png)

Figura 1: Resumen de operadores

---
layout: false
class: center middle section-title-2 top-logo

# Redoble de tambores, el más importante de la fiesta 🥁

---
layout: true
class: title title-2

---
# Operador pipeline %>% 

- `%>%` (llamado `pipe`) no es un operador que esté contenido en las funciones base del lenguaje R (origen `magrittr` de `tidyverse`)

- Es de los operadores **más útiles y utilizados** en R.

--

**En el teclado**

- `Ctrl + shift + M` Para Windows
- `⌘ + shift + M` Para Mac


---
# Operador pipeline %>% 

- Función: **concatenar** múltiples funciones y procesos.

--

- ¿Cómo es eso? 🤨

--
- ¡Tranquila/o! Ya lo veremos 🧘🏽‍♂️

---

# ¡Ya queremos ir a practicar! 🏃🏽‍♀️🏃🏽

---

# Transformación y selección de variables con `dplyr()`

--

1.  `select()` para seleccionar variables

--

2.  `filter()` para filtrar observaciones

--

3. `mutate()` crear nuevas variables
  
  -  `recode()`, `if_else()`, `case_when()`

---

# `select()` para manipular variables

- Para **seleccionar variables** ocuparemos `select()`.

--

Si queremos incluir las variables `variable1`, `variable2` y `variable3`
```{r, eval = F}
select(datos, variable1, variable2, variable3)
```

--
Si queremos excluir anteponemos un menos `-variable1`

```{r, eval = F}
select(datos, -variable1)
```

---
# Formas de hacer `select()`

1. Por indexación

```{r}
select(datos, 1,2) # la primera y la segunda columna
select(datos, 1:4) # la primera hasta la cuarta columna

```

2. por nombre de columna

```{r}
select(datos, edad, sexo, o1)
```

---
# Trucos de `select()`

1. Renombrar en el mismo proceso de selección indicando `nuevo_nombre = nombre_original` en el proceso de selección

```{r}
select(datos, edad, sexo, ocupacion = o1)
```

2. Reordenar variables

- `everything()` nos indica que ponga "todo el resto".

```{r}
select(datos, id_persona, sexo, edad, everything())
```

---

# Formas de hacer `select()`

3. Con patrones de texto: prefijos, sufijos o partes de *cómo están nombradas las variables*.

- Poner textos y expresiones regulares entre **comillas**.

- `starts_with()`: prefijo 
- `ends_with() `:  sufijo
- `contains()` : contiene una cadena de texto literal
- `matches()` : coincide con una expresión regular

---
# Formas de hacer `select()`

```{r}
select(datos, starts_with("a"), ends_with("preg"))

# También se pueden combinar con operadores logicos

select(datos, starts_with("y1")&ends_with("preg")) 
select(datos, contains("pobre")|contains("vivienda"))
select(datos, matches("pobreza_|vivienda"))
```

---
# Formas de hacer `select()`

4. Con condiciones lógicas

- `select()` + `where()`:  *"seleciona donde"*, ese *donde* responde a una condición que cumple cierta variable.

- Por ejemplo, queremos seleccionar todas las variables que son carácteres (`is.character`):

```{r}
select(datos, where(is.character))
```

---
layout: false

- Luego de la exploración de datos mediante a funciones como `find_var()` de `sjmisc` decidimos trabajar con las siguientes variables.

- `edad`
- `sexo`
- `s13`: previsión de salud
- `tot_per`: número de personas en el hogar
- `ytoth`: ingresos totales del hogar
- `o1`: ocupación
- `y26d_total`: Monto del IFE
- `y26d_hog`: ¿Alguien recibió el IFE?

¡Apliquémos conocimientos!

```{r}
select(datos, edad, sexo, prev =592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&matches("total|hog"))
```

---
layout: true
class: title title-4
---
# Nuevo data set

- Buena práctica trabajar solo con las columnas que utilizaremos para el análisis, principalmente pues disminuye el *uso de memoria*

```{r}
datos_proc <- select(datos, edad, sexo, prev = 592, ocupacion = o1, tot_per, ytoth, starts_with("y26d_")&matches("total|hog"))
```

---

# ¡Ejercicio en grupos!

--

- Seleccionen una variable de nivel educacional, region, sexo, la variable 700 y todas las que refieran a ingresos.

- Indiquen cómo hicieron ese procedimiento

- Con estos cambios, creen un nuevo objeto llamado `ejercicio`

---


# ¿Qué pasa si quiero trabajar con un *subset* de casos?

--

# La respuesta es `filter()`

---

# `filter()` para manipular observaciones

- La función `filter()` de `dplyr` escoge o extrae filas basados en sus valores, subdivide un data frame (*subset*)

- Uso de los **operadores**

--

```{r, eval = F}
filter(datos, condicion_para filtrar)
```

Imaginemos que queremos filtrar valores mayores o iguales 3 **respecto a la variable1**

```{r, eval = F}
filter(datos, variable1 >= 3)
```

---
# Formas de `filter()`

1. Con números

Imaginémos que queremos una base con las personas mayores de 15 años. 
```{r}
filter(datos_proc, edad >= 15)
filter(datos_proc, edad >= 15 & tot_per <7)
```

--

Pero también que pertenezcan a hogares con menos de 7 personas. 
```{r}
filter(datos_proc, edad >= 15 & tot_per <7)
```

---
# Formas de `filter()`

2. Con carácteres

- Importancia de explorar los datos
  1. Fijarse bien cómo están escritos
  2. Clase (ver si efectivamente son carácteres)

- R es *sensible* a cómo está escrito el texto (*key sensitive*)

---
# Truco

- Cuando haya problemas aplicar `as_factor()` que permite conservar los niveles pero definiendo sus categorías de respuesta en base a la etiqueta que traen (el `lbl`)

- Consejo útil sobre todo en bases que provienen de SPSS y STATA

---
# Formas de `filter()`

```{r}
datos_proc$sexo <- as_factor(datos_proc$sexo)
```

```{r}
filter(datos_proc, sexo == "Mujer")
filter(datos_proc, sexo != "Hombre")
```

---
# Un clásico, y la solución: %in%

- ¿Cómo se seleccionan dos condiciones en carácter? Con el operador `%in%`

```{r}
datos_proc$prev <- as_factor(datos_proc$prev)

filter(datos_proc, prev %in% c("Sistema Público FONASA", "ISAPRE"))
```

---
# Ejercicio

- Con su data frame `ejercicio` filtren
  - Excluyan a las personas sin estudios
  - Filtren a la persona con máximos ingresos del hogar
  - Conserven a las personas de la RM y Valparaíso. 

---
class: center middle section-title-4 top-logo

# ¿Y si quiero crear variables nuevas?

--

.box-5[`mutate()`]
---

# `mutate()` para transformación de  variables

- `mutate()` permite hacer operaciones para crear nuevas variables o transformar las ya existentes. 

```{r, eval = F}
mutate(datos, nueva_variable = cálculo o condición)
```

---
# Formas de hacer `mutate()`

1. En base a cálculo

```{r echo=TRUE}
mutate(datos_proc, nueva_variable = 3+2)
mutate(datos_proc, nueva_variable = 3+2,
       ingreso_percapita = ytoth/tot_per)
```

---
class: center middle section-title-4 top-logo

# Aquí mucha mucha atención...

--

# Viene la aplicación de  %>%

.box-inv-4[¿Qué pasa si queremos, luego de calcular nuestras nuevas variables, filtrar un ingreso per cápita menor o igual a $1.000.000]

---
# `%>%`

```{r}
datos %>% 
  mutate(., nueva_variable = calculo ) %>% 
  filter(., nueva_variable <= valor)

```

--

- Básicamente, el ` %>% ` permite "ingresar" nuestra base de datos como argumento para cada función e ir operándola en proceso

---
# `%>%` 

```{r}
datos_proc %>%
  mutate(ingreso_percapita = ytoth/tot_per) %>% 
  filter(ingreso_percapita <= 1000000)
```
--
 
**En el teclado**

- `Ctrl + shift + M` Para Windows
- `⌘ + shift + M` Para Mac

---
layout: false
class: center middle section-title-5 top-logo

# Crear nuevas variables utilizando *además* otras funciones

--

## mutate(variable_nueva = alguna_funcion_genial)


---
layout: true
class: title title-5

# Opciones para recodificar.

- `dplyr::recode()` y  `car::recode()` 

- Con `dplyr::recode()`: recodificamos las categorías de respuesta de Mujer a Femenino y de Hombre a Masculino

```{r}
datos_proc %>% 
  mutate(sexo = dplyr::recode(sexo, "Mujer" = "Femenino", "Hombre" = "Masculino"))
```

- El problema de `recode()` que se utiliza dentro de `dplyr` es que si recodifico se pierde la etiqueta anterior.

---
# Mi elección: `car::recode()`

- **No olviden** los `::` por los posibles conflictos

```{r}
car::recode(datos$variable, c('valor_orig1=nuevo_valor1;valor_org2=nuevo_valor2'))
```

---
# Mi elección: `car::recode()`

```{r}
datos_proc %$% 
  car::recode(.$y26d_hog, c('9=NA')) %>% head(.)
```

Aquí una versión de si la recodificación es hacia carácteres (mismo ejemplo que con `recode()` de `dplyr`)

```{r}
datos_proc %$% 
  car::recode(.$sexo,
              c('"Mujer"="Femenino";"Hombre"= "Masculino"'),
              as.factor = T) %>% head(.)
```

---
.small[
# `if_else()` variables condicionales
]

La función `if_else()` permite construir variables en base a condiciones lógicas. Su estructura es la siguiente

```{r}
if_else(condición,TRUE,FALSE)

```


---
.small[
# `if_else()`  variables condicionales
]
Crearemos una variable que *dummy* que indica si el respondente es *FONASA* o no lo es. 

```{r eval=FALSE, include=TRUE}
datos_proc %>% 
 		 mutate(fonasa = if_else(prev == "Sistema Público FONASA", 1, 0))
```

---
.small[
# `if_else()` variables condicionales
]
- Uno/a puede ser *ingenioso* y ocuparla como **validador**

```{r echo=TRUE}
datos_proc %>% 
  mutate(validador_ingreso = if_else(is.na(ytoth), FALSE, TRUE))
```

- También para *imputar valores* ¿cómo sería?

---
.small[
# `case_when()`  variables con múltiples condiciones
]
- Para *colapsar* categorías o construir categorías en base a varias condiciones es `case_when()` por lo lógico y *fácil* que es de entender

```{r}
case_when(variable == condicion ~ valor1,
          variable == condicion ~ valor2,
          TRUE ~ NA_real)
```

- Donde, TRUE indica "todo el resto", y el NA dependerá de la clase del valor de recodificación

---
.small[
# `case_when()` variables con múltiples condiciones
]
Un ejemplo claro es cuando queremos construir *categorías de edad*

```{r}
datos_proc %>% 
  mutate(edad_tramo = case_when(edad <=39 ~  "Joven",
                                edad > 39 & edad <=59 ~ "Adulto",
                                edad > 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_)) %>% 
  select(edad, edad_tramo)
```

- ¡Utilizamos operadores lógicos (`&`)!


---
# ¡Resumen!
```{r}
datos_proc %>% 
 filter(edad >= 15 & tot_per <7) %>%
    mutate(ingreso_percapita = ytoth/tot_per,
           edad_tramo = case_when(edad <=39 ~  "Joven",
                                edad > 39 & edad <=59 ~ "Adulto",
                                edad > 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_),
           fonasa = if_else(prev == "Sistema Público FONASA", 1, 0),
           ocupacion = as_factor(ocupacion)) %>%
  select(sexo, edad_tramo, ocupacion, ingreso_percapita, ife = y26d_hog)
```

---
# ¡Resumen!
¡Ahora que estamos seguras/os sobre-escribimos la base!
```{r}
datos_proc <- datos_proc %>% 
 filter(edad >= 15 & tot_per <7) %>%
    mutate(ingreso_percapita = ytoth/tot_per,
           edad_tramo = case_when(edad <=39 ~  "Joven",
                                edad > 39 & edad <=59 ~ "Adulto",
                                edad > 59 ~ "Adulto mayor",
                                TRUE ~ NA_character_),
           fonasa = if_else(prev == "Sistema Público FONASA", 1, 0),
           ocupacion = as_factor(ocupacion)) %>%
  select(sexo, edad_tramo, ocupacion, ingreso_percapita, ife = y26d_hog)
```

---
# Antes de guardar

Podemos visualizar la base resultante a partir de `view_df()` de `sjPlot`
```{r, message= F, error= F, cache.comments= F}
sjPlot::view_df(datos_proc)
```

---
# Paso 4: Guardar datos

Para guardar la base de datos procesada, debes dirigir la ruta hacia tu Rproject

```{r eval=FALSE, include=TRUE}
saveRDS(datos_proc, file = "../nombre_project/output/datos_proc.rds")
```

- Recuerda revisar el [practico N°2](example/02-practico) si no recuerdas como expoertar datos.

---
layout: false
class: center section-title section-title-5 animated fadeIn

# En síntesis

.box-2.medium.sp-after-half[**Básicos en manipulación**]
.small.box-2[Operadores y tipos de datos]

--

.box-3.medium.sp-after-half[**Seleccionar variables**]

--

.box-4.medium.sp-after-half[**Filtrar**]

--

.box-5.medium.sp-after-half[**Crear variables**]

---
class: center middle main-title section-title-4 top-logo

# ¡Y a no olvidar el flujo para el análisis!

--

## Nos permite hacernos amigas/os más rápido del programa
---

.center[
![:scale 80%](https://github.com/learn-R/slides/raw/main/img/01/flow-rproject.png)]

---
layout: false

.box-1[¿Y eso era?]

--

.box-inv-1[¡Ahora si que si! Nos vemos el próximo viernes en la última sesión]

.center[
![](https://github.com/learn-R/slides/raw/main/img/01/monster-inc-2.gif)]
---
layout: false
class: center middle main-title section-title-1 top-logo

.small[
# Muestras complejas y precisión de inferencia estadística
]

.class-info[
<br>
**Sesión N° 4**<br>
`r format(Sys.Date(), '%d %B %Y')`<br>
**Análisis de datos estadísticos en R**
<br>

.pull-right.small[
**Profesora** Valentina Andrade de la Horra <br>
**Ayudantes** Dafne Jaime y Nicolás Godoy
.tiny[Universidad Alberto Hurtado<br>
]
]

]

???
https://c.tenor.com/7mxJp29REVkAAAAC/scaryfeet-monstersinc.gif
